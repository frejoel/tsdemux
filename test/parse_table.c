#include "test.h"
#include <tsdemux.h>
#include <stdio.h>
#include <string.h>

void test_input(void);
void test_parse_longform_table(void);
void test_parse_shortform_table(void);
void test_parse_multi_packet_table(void);

int main(int argc, char **argv)
{
    test_input();
    test_parse_longform_table();
    test_parse_shortform_table();
    test_parse_multi_packet_table();
    return 0;
}

void test_input(void)
{
    test_start("tsd_parse_table inputs");

    TSDemuxContext ctx;
    TSDPacket pkt;
    TSDTable table;
    TSDCode res;

    pkt.sync_byte = 'G';
    pkt.flags = TSD_PF_PAYLOAD_UNIT_START_IND;
    pkt.pid = 0x00;
    pkt.transport_scrambling_control = TSD_SC_NO_SCRAMBLING;
    pkt.adaptation_field_control = TSD_AFC_NO_FIELD_PRESENT;
    pkt.continuity_counter = 0;
    pkt.data_bytes = NULL;
    pkt.data_bytes_length = 0;

    tsd_context_init(&ctx);

    res = tsd_parse_table(NULL, NULL, NULL);
    test_assert_equal(res, TSD_INVALID_CONTEXT, "all null");
    res = tsd_parse_table(&ctx, NULL, NULL);
    test_assert_equal(res, TSD_INVALID_ARGUMENT, "null packet");
    res = tsd_parse_table(&ctx, &pkt, NULL);
    test_assert_equal(res, TSD_INVALID_ARGUMENT, "null table");

    test_end();
}

void test_parse_longform_table(void)
{
    test_start("tsd_parse_table parsing long form table");

    TSDemuxContext ctx;
    TSDPacket pkt;
    TSDTable table;
    TSDCode res;

    // this is a long form table
    uint8_t tableData[] = {
        0x01, // pointer field
        0xFF, // padding
        0x01, // table id
        0b10110000, // section syntax indicator, 4 bits of section length (0000)
        0x10, // rest of the section length (16)
        0xFA, // transport stream id
        0xEB, // transport stream id cont.
        0b11011101, // reserved, version number, current next indicator
        0x00, // section number
        0x00, // last section number
        0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, // random bytes
        0xFF, // end of table
        // 21 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // +64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // +64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF,
        // +34 bytes
    };

    pkt.sync_byte = 'G';
    pkt.flags = TSD_PF_PAYLOAD_UNIT_START_IND;
    pkt.pid = 0x00;
    pkt.transport_scrambling_control = TSD_SC_NO_SCRAMBLING;
    pkt.adaptation_field_control = TSD_AFC_NO_FIELD_PRESENT;
    pkt.continuity_counter = 0;
    pkt.data_bytes = tableData;
    pkt.data_bytes_length = sizeof(tableData);

    tsd_context_init(&ctx);

    res = tsd_parse_table(&ctx, &pkt, &table);
    test_assert_equal(res, TSD_OK, "valid table");
    test_assert_equal(1, table.length, "table length");
    TSDTableSection *sec = &table.sections[0];
    test_assert_equal(sec->table_id, 0x01, "table id");
    test_assert_equal(sec->flags & TSD_TBL_SECTION_SYNTAX_INDICATOR, TSD_TBL_SECTION_SYNTAX_INDICATOR, "section syntax indicator");
    test_assert_equal(sec->flags & TSD_TBL_CURRENT_NEXT_INDICATOR, TSD_TBL_CURRENT_NEXT_INDICATOR, "current next indicator");
    test_assert_equal(sec->section_length, 0x10, "section length");
    test_assert_equal(sec->table_id_extension, 0xFAEB, "transport stream id");
    test_assert_equal(sec->version_number, 0b00001110, "version");
    test_assert_equal(sec->section_number, 0x00, "section number");
    test_assert_equal(sec->last_section_number, 0x00, "last section number");

    test_end();
}

void test_parse_shortform_table(void)
{
    test_start("tsd_parse_table parsing short form tables");

    TSDemuxContext ctx;
    TSDPacket pkt;
    TSDTable table;
    TSDCode res;

    // this is a short form table
    uint8_t tableData[] = {
        0x01, // pointer field
        0xFF, // padding
        0xEA, // table id
        0b00110000, // section syntax indicator, 4 bits of section length (0000)
        0x10, // rest of the section length (16)
        0xFA, 0xEB, 0xFF, 0x00, 0x00, 0x06, 0x07, 0x08,
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
        0xFF, // end of table
        // 21 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // +64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // +64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF,
        // +34 bytes
    };

    pkt.sync_byte = 'G';
    pkt.flags = TSD_PF_PAYLOAD_UNIT_START_IND;
    pkt.pid = 0x00;
    pkt.transport_scrambling_control = TSD_SC_NO_SCRAMBLING;
    pkt.adaptation_field_control = TSD_AFC_NO_FIELD_PRESENT;
    pkt.continuity_counter = 0;
    pkt.data_bytes = tableData;
    pkt.data_bytes_length = sizeof(tableData);

    tsd_context_init(&ctx);

    res = tsd_parse_table(&ctx, &pkt, &table);
    test_assert_equal(res, TSD_OK, "valid table");
    test_assert_equal(1, table.length, "table length");
    TSDTableSection *sec = &table.sections[0];
    test_assert_equal(sec->table_id, 0xEA, "table id");
    test_assert_equal(sec->flags & TSD_TBL_SECTION_SYNTAX_INDICATOR, 0, "section syntax indicator");
    test_assert_equal(sec->flags & TSD_TBL_CURRENT_NEXT_INDICATOR, 0, "current next indicator");
    test_assert_equal(sec->section_length, 0x10, "section length");
    test_assert_equal(sec->table_id_extension, 0, "transport stream id");
    test_assert_equal(sec->version_number, 0, "version");
    test_assert_equal(sec->section_number, 0, "section number");
    test_assert_equal(sec->last_section_number, 0, "last section number");

    test_end();
}

void test_parse_multi_packet_table(void)
{
    test_start("tsd_parse_table parsing multi packet table");

    TSDemuxContext ctx;
    TSDPacket pkt;
    TSDPacket pkt2;
    TSDTable table;
    TSDCode res;

    // this is a long form table
    uint8_t tableData[] = {
        0x00, // pointer field
        0xC2, // table id
        0b10110000, // section syntax indicator, 4 bits of section length (0000)
        0x10, // rest of the section length (16)
        0x34, // transport stream id
        0x9A, // transport stream id cont.
        0b10000100, // reserved, version number, current next indicator
        0x00, // section number
        0x02, // last section number
        0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, // random bytes
        // 29 bytes
        0xD3, // table id
        0b10110000, // section syntax indicator, 4 bits of section length (0000)
        0x10, // rest of the section length (16)
        0x45, // transport stream id
        0xAB, // transport stream id cont.
        0b10000100, // reserved, version number, current next indicator
        0x01, // section number
        0x02, // last section number
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0D, 0x0F, 0x10, 0x11, 0x12, // random bytes
        // +19 bytes
        0xE4, // table id
        0b10110000, // section syntax indicator, 4 bits of section length (0000)
        0x9E, // rest of the section length (158 bytes)
        0x56, // transport stream id
        0xBC, // transport stream id cont.
        0b10000100, // reserved, version number, current next indicator
        0x02, // section number
        0x02, // last section number
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0D, 0x0F,
        0x10, 0x11, 0x12,
        // +19 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // +64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // +46 bytes
        // The section_length says there is more data to this table
    };

    uint8_t tableData2[] = {
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // stuffing
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // +64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // +64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // + 64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        // + 64 bytes
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    };

    pkt.sync_byte = 'G';
    pkt.flags = TSD_PF_PAYLOAD_UNIT_START_IND;
    pkt.pid = 0x00;
    pkt.transport_scrambling_control = TSD_SC_NO_SCRAMBLING;
    pkt.adaptation_field_control = TSD_AFC_NO_FIELD_PRESENT;
    pkt.continuity_counter = 0;
    pkt.data_bytes = tableData;
    pkt.data_bytes_length = sizeof(tableData);

    pkt2.sync_byte = 'G';
    pkt2.flags = 0;
    pkt2.pid = 0x00;
    pkt2.transport_scrambling_control = TSD_SC_NO_SCRAMBLING;
    pkt2.adaptation_field_control = TSD_AFC_NO_FIELD_PRESENT;
    pkt2.continuity_counter = 0;
    pkt2.data_bytes = tableData2;
    pkt2.data_bytes_length = sizeof(tableData2);

    tsd_context_init(&ctx);

    res = tsd_parse_table(&ctx, &pkt, &table);
    test_assert_equal(res, TSD_INCOMPLETE_TABLE, "incomplete table");
    res = tsd_parse_table(&ctx, &pkt2, &table);
    test_assert_equal(res, TSD_OK, "complete table");
    test_assert_equal(3, table.length, "table length");

    TSDTableSection *sec1 = &table.sections[0];
    TSDTableSection *sec2 = &table.sections[1];
    TSDTableSection *sec3 = &table.sections[2];

    test_assert_equal(sec1->table_id, 0xC2, "table id 1");
    test_assert_equal(sec2->table_id, 0xD3, "table id 2");
    test_assert_equal(sec3->table_id, 0xE4, "table id 3");
    test_assert_equal(sec1->flags & TSD_TBL_SECTION_SYNTAX_INDICATOR, TSD_TBL_SECTION_SYNTAX_INDICATOR, "section syntax indicator 1");
    test_assert_equal(sec2->flags & TSD_TBL_SECTION_SYNTAX_INDICATOR, TSD_TBL_SECTION_SYNTAX_INDICATOR, "section syntax indicator 2");
    test_assert_equal(sec3->flags & TSD_TBL_SECTION_SYNTAX_INDICATOR, TSD_TBL_SECTION_SYNTAX_INDICATOR, "section syntax indicator 3");
    test_assert_equal(sec1->flags & TSD_TBL_CURRENT_NEXT_INDICATOR, 0, "current next indicator 1");
    test_assert_equal(sec2->flags & TSD_TBL_CURRENT_NEXT_INDICATOR, 0, "current next indicator 2");
    test_assert_equal(sec3->flags & TSD_TBL_CURRENT_NEXT_INDICATOR, 0, "current next indicator 3");
    test_assert_equal(sec1->section_length, 0x10, "section length 1");
    test_assert_equal(sec2->section_length, 0x10, "section length 2");
    test_assert_equal(sec3->section_length, 0x9E, "section length 3");
    test_assert_equal(sec1->table_id_extension, 0x349A, "transport stream id 1");
    test_assert_equal(sec2->table_id_extension, 0x45AB, "transport stream id 2");
    test_assert_equal(sec3->table_id_extension, 0x56BC, "transport stream id 3");
    test_assert_equal(sec1->version_number, 0b00000010, "version 1");
    test_assert_equal(sec2->version_number, 0b00000010, "version 2");
    test_assert_equal(sec3->version_number, 0b00000010, "version 3");
    test_assert_equal(sec1->section_number, 0x00, "section number 1");
    test_assert_equal(sec2->section_number, 0x01, "section number 2");
    test_assert_equal(sec3->section_number, 0x02, "section number 3");
    test_assert_equal(sec1->last_section_number, 0x02, "last section number 1");
    test_assert_equal(sec2->last_section_number, 0x02, "last section number 2");
    test_assert_equal(sec3->last_section_number, 0x02, "last section number 3");

    test_end();
}
